# ───────────────────────────────────────────────────────────
# 파이프라인 생성 조건
#  - MR 타겟이 master → 빌드만
#  - master 에 push/merge → 빌드 후 배포
# ───────────────────────────────────────────────────────────
workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "master"'
    - if: '$CI_COMMIT_BRANCH == "master"'
    - when: never

stages: [build, deploy]

# 전역 변수
variables:
  BE_APP: "duckon-app-prod"
  FE_APP: "duckon-front-prod"

# 러너 태그
.default_tags: &default_tags
  tags: ["duckon","dind"]

# ───────────────────────────────────────────────────────────
# BE 빌드
# ───────────────────────────────────────────────────────────
build_backend:
  stage: build
  <<: *default_tags
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "master"'
    - if: '$CI_COMMIT_BRANCH == "master"'
  image: gradle:8.6-jdk21
  variables:
    GRADLE_USER_HOME: "$CI_PROJECT_DIR/.gradle"
  script:
    - cd backend
    - chmod +x ./gradlew || true
    - ./gradlew --no-daemon clean build

# ───────────────────────────────────────────────────────────
# FE 빌드
# ───────────────────────────────────────────────────────────
build_frontend:
  stage: build
  <<: *default_tags
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "master"'
    - if: '$CI_COMMIT_BRANCH == "master"'
  image: node:20-alpine
  script:
    - cd frontend
    - npm ci
    - VITE_API_BASE_URL="${VITE_API_BASE_URL_PROD:-/api}" npm run build

# ───────────────────────────────────────────────────────────
# PROD 배포 (SSM 원격 실행; 원격에서만 docker 사용)
# ───────────────────────────────────────────────────────────
deploy_prod:
  stage: deploy
  tags: ["duckon","dind"]
  image:
    name: amazon/aws-cli:2.17.60
    entrypoint: ["/bin/bash","-lc"]
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "master"'
    - when: never
  needs: [build_backend, build_frontend]
  before_script:
    - set -eo pipefail
    - yum -y install jq bash
    # 변수 검증
    - '[ -n "$AWS_ACCESS_KEY_ID_PROD" ] || { echo "Missing CI var: AWS_ACCESS_KEY_ID_PROD"; exit 1; }'
    - '[ -n "$AWS_SECRET_ACCESS_KEY_PROD" ] || { echo "Missing CI var: AWS_SECRET_ACCESS_KEY_PROD"; exit 1; }'
    - '[ -n "$AWS_REGION_PROD" ] || { echo "Missing CI var: AWS_REGION_PROD"; exit 1; }'
    # AWS 인증
    - export AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID_PROD"
    - export AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY_PROD"
    - export AWS_DEFAULT_REGION="$AWS_REGION_PROD"
    - aws sts get-caller-identity
  script: |
    echo "[Build remote deployment script]"
    cat > remote-script.sh <<'EOS'
    set -eux

    # 사전 진단 (문제시 바로 이유가 보이도록)
    command -v docker || { echo "[ERROR] docker not installed"; exit 21; }
    command -v git    || { echo "[ERROR] git not installed";    exit 22; }
    command -v curl   || { echo "[WARN] curl missing; installing may be needed"; }

    # 네트워크 선택
    NET=$(docker inspect -f '{{range $k,$v := .NetworkSettings.Networks}}{{printf "%s " $k}}{{end}}' duckon-proxy 2>/dev/null | awk '{print $1}')
    [ -z "$NET" ] && NET="bridge"
    echo "Using network: $NET"

    WORKDIR="/srv/duckon/app"
    mkdir -p "$WORKDIR"
    cd "$WORKDIR"

    # 필수 env 파일 체크 (없으면 바로 이유를 보여주자)
    if [ ! -f /srv/duckon/compose/prod.env ]; then
      echo "[ERROR] /srv/duckon/compose/prod.env not found"
      ls -l /srv/duckon || true
      exit 23
    fi

    # 코드 동기화
    ORIGIN="https://gitlab-ci-token:${CI_JOB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    if [ -d .git ]; then
      git remote set-url origin "$ORIGIN"
      git fetch --all --prune
    else
      git init
      git remote add origin "$ORIGIN"
      git fetch origin
    fi
    git reset --hard "${CI_COMMIT_SHA}"

    echo "[BE] docker build"
    docker build -t duckonback:prod -f backend/Dockerfile backend

    echo "[BE] restart ${BE_APP}"
    docker rm -f "${BE_APP}" 2>/dev/null || true
    docker run -d --name "${BE_APP}" \
      --network "$NET" \
      --env-file "/srv/duckon/compose/prod.env" \
      -e SPRING_PROFILES_ACTIVE=prod \
      -e JAVA_OPTS="-Xms256m -Xmx512m" \
      --restart unless-stopped \
      duckonback:prod

    echo "[FE] docker build (VITE_API_BASE_URL=${VITE_API_BASE_URL_PROD:-/api})"
    docker build \
      --build-arg NGINX_CONF=nginx.prod.conf \
      --build-arg VITE_API_BASE_URL="${VITE_API_BASE_URL_PROD:-/api}" \
      -t duckonfront:prod \
      -f frontend/Dockerfile frontend

    echo "[FE] restart ${FE_APP}"
    docker rm -f "${FE_APP}" 2>/dev/null || true
    docker run -d --name "${FE_APP}" \
      --network "$NET" \
      --restart unless-stopped \
      duckonfront:prod

    docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}'

    echo "[Healthcheck]"
    i=1
    while [ $i -le 30 ]; do
      code=$(curl -ksS -o /dev/null -w "%{http_code}" https://duckon.site/api/actuator/health || true)
      [ "$code" = "200" ] || [ "$code" = "401" ] && { echo "OK ($code)"; exit 0; }
      echo "retry $i/30"; i=$((i+1)); sleep 3
    done
    echo "healthcheck failed"; exit 31
    EOS

    # JSON 파라미터로 안전하게 전달
    jq -n --arg script "$(cat remote-script.sh)" '{commands: [$script]}' > ssm-params.json

    echo "[Send command to SSM]"
    CMD_ID=$(aws ssm send-command \
      --instance-ids "$PROD_INSTANCE_ID" \
      --document-name "AWS-RunShellScript" \
      --comment "DuckOn prod deploy $CI_COMMIT_SHA" \
      --parameters file://ssm-params.json \
      --query "Command.CommandId" \
      --output text)
    echo "CommandId: $CMD_ID"

    echo "[Poll & print logs until terminal state]"
    # 실패여도 반드시 원격 STDOUT/STDERR를 출력
    while :; do
      OUT=$(aws ssm get-command-invocation \
        --command-id "$CMD_ID" \
        --instance-id "$PROD_INSTANCE_ID" \
        --output json || true)

      STATUS=$(echo "$OUT" | jq -r '.Status // empty')
      STDOUT=$(echo "$OUT" | jq -r '.StandardOutputContent // ""')
      STDERR=$(echo "$OUT" | jq -r '.StandardErrorContent // ""')

      echo "SSM Status: ${STATUS:-unknown}"
      [ -n "$STDOUT" ] && echo "----- STDOUT -----"$'\n'"$STDOUT"
      [ -n "$STDERR" ] && echo "----- STDERR -----"$'\n'"$ERR"

      case "$STATUS" in
        Pending|InProgress|Delayed|"")
          sleep 3
          ;;
        Success)
          exit 0
          ;;
        Cancelled|TimedOut|Failed|Cancelling)
          # 실패여도 마지막 로그를 보고 종료 코드 1로 명확히 실패 처리
          echo "----- END LOGS -----"
          echo "$OUT" | jq -r '.StandardErrorContent // ""'
          exit 1
          ;;
      esac
    done
