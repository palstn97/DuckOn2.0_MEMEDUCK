# ───────────────────────────────────────────────────────────
# 파이프라인 생성 조건
#  - MR 타겟이 master → 빌드만
#  - master 에 push/merge → 빌드 후 배포
# ───────────────────────────────────────────────────────────
workflow:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "master"'
    - if: '$CI_COMMIT_BRANCH == "master"'
    - when: never

stages: [build, deploy]

# 전역 변수
variables:
  BE_APP: "duckon-app-prod"
  FE_APP: "duckon-front-prod"

# 러너 태그
.default_tags: &default_tags
  tags: ["duckon","dind"]

# ───────────────────────────────────────────────────────────
# BE 빌드
# ───────────────────────────────────────────────────────────
build_backend:
  stage: build
  <<: *default_tags
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "master"'
    - if: '$CI_COMMIT_BRANCH == "master"'
  image: gradle:8.6-jdk21
  variables:
    GRADLE_USER_HOME: "$CI_PROJECT_DIR/.gradle"
  script:
    - cd backend
    - chmod +x ./gradlew || true
    - ./gradlew --no-daemon clean build

# ───────────────────────────────────────────────────────────
# FE 빌드
# ───────────────────────────────────────────────────────────
build_frontend:
  stage: build
  <<: *default_tags
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "master"'
    - if: '$CI_COMMIT_BRANCH == "master"'
  image: node:20-alpine
  script:
    - cd frontend
    - npm ci
    - VITE_API_BASE_URL="${VITE_API_BASE_URL_PROD:-/api}" npm run build

# ───────────────────────────────────────────────────────────
# PROD 배포 (SSM 원격 실행; 원격에서만 docker 사용)
# ───────────────────────────────────────────────────────────
deploy_prod:
  stage: deploy
  <<: *default_tags
  image:
    name: amazon/aws-cli:2.17.60
    entrypoint: ["/bin/sh","-lc"]
  rules:
    - if: '$CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH == "master"'
    - when: never
  needs: [build_backend, build_frontend]
  before_script:
    - set -eo pipefail
    - yum -y install bash
    - '[ -n "$AWS_ACCESS_KEY_ID_PROD" ] || { echo "Missing CI var: AWS_ACCESS_KEY_ID_PROD"; exit 1; }'
    - '[ -n "$AWS_SECRET_ACCESS_KEY_PROD" ] || { echo "Missing CI var: AWS_SECRET_ACCESS_KEY_PROD"; exit 1; }'
    - '[ -n "$AWS_REGION_PROD" ] || { echo "Missing CI var: AWS_REGION_PROD"; exit 1; }'
    - export AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID_PROD"
    - export AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY_PROD"
    - export AWS_DEFAULT_REGION="$AWS_REGION_PROD"
    - aws sts get-caller-identity >/dev/null
    - set -euo pipefail
  script: |
    bash -lc '
    set -euo pipefail

    BE_APP="'"$BE_APP"'"
    FE_APP="'"$FE_APP"'"
    CI_HOST="'"$CI_SERVER_HOST"'"
    CI_PATH="'"$CI_PROJECT_PATH"'"
    CI_TOKEN="'"$CI_JOB_TOKEN"'"
    COMMIT="'"$CI_COMMIT_SHA"'"
    VITE_API="${VITE_API_BASE_URL_PROD:-/api}"

    read -r -d "" REMOTE <<EOS
    set -euxo pipefail
    CI_HOST="$CI_HOST"
    CI_PATH="$CI_PATH"
    CI_TOKEN="$CI_TOKEN"
    COMMIT="$COMMIT"
    VITE_API="$VITE_API"
    BE_APP="$BE_APP"
    FE_APP="$FE_APP"

    NET="duckon-net"
    docker network create "\$NET" 2>/dev/null || true

    WORKDIR="/srv/duckon/app"
    mkdir -p "\$WORKDIR"
    cd "\$WORKDIR"

    ORIGIN="https://gitlab-ci-token:\${CI_TOKEN}@\${CI_HOST}/\${CI_PATH}.git"
    if [ -d .git ]; then
      git remote set-url origin "\$ORIGIN"
      git fetch --all --prune
    else
      git init
      git remote add origin "\$ORIGIN"
      git fetch origin
    fi
    git reset --hard "\$COMMIT"

    echo "[BE] docker build"
    docker build -t duckonback:prod -f backend/Dockerfile backend

    echo "[BE] restart \$BE_APP"
    docker rm -f "\$BE_APP" 2>/dev/null || true
    docker run -d --name "\$BE_APP" \
      --network "\$NET" \
      --env-file "/srv/duckon/prod.env" \
      -e SPRING_PROFILES_ACTIVE=prod \
      -e JAVA_OPTS="-Xms256m -Xmx512m" \
      --restart unless-stopped \
      duckonback:prod

    echo "[FE] docker build (VITE_API_BASE_URL=\${VITE_API})"
    docker build \
      --build-arg NGINX_CONF=nginx.prod.conf \
      --build-arg VITE_API_BASE_URL="\$VITE_API" \
      -t duckonfront:prod \
      -f frontend/Dockerfile frontend

    echo "[FE] restart \$FE_APP"
    docker rm -f "\$FE_APP" 2>/dev/null || true
    docker run -d --name "\$FE_APP" \
      --network "\$NET" \
      --restart unless-stopped \
      duckonfront:prod

    docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"

    i=1
    while [ \$i -le 30 ]; do
      code=\$(curl -ksS -o /dev/null -w "%{http_code}" https://duckon.site/api/actuator/health || true)
      [ "\$code" = "200" ] || [ "\$code" = "401" ] && { echo "BE health OK (\$code)"; break; }
      echo "BE health retry \$i/30..."; i=\$((i+1)); sleep 3
    done
    curl -sI https://duckon.site | head -n1 || true

    git remote set-url origin "https://\${CI_HOST}/\${CI_PATH}.git" || true
    EOS

    CMD_ID=$(aws ssm send-command \
      --instance-ids "'"$PROD_INSTANCE_ID"'" \
      --document-name "AWS-RunShellScript" \
      --comment "DuckOn Prod deploy '"$CI_COMMIT_SHA"' (no-registry)" \
      --parameters commands="$REMOTE" \
      --query "Command.CommandId" \
      --output text)

    echo "CommandId: $CMD_ID"
    aws ssm wait command-executed --command-id "$CMD_ID" --instance-id "'"$PROD_INSTANCE_ID"'"
    aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "'"$PROD_INSTANCE_ID"'" --output table
    '
