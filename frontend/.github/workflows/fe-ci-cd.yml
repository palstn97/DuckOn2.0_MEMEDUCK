name: FE Dev/Prod CI/CD (dev=SSH, prod=SSM)

on:
  pull_request:
    branches: [ develop, main ]   # PR: 빌드만
  push:
    branches: [ develop, main ]   # push/merge: 빌드+배포
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: duckonfront

jobs:
  pr-build:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Compute lowercase owner
        run: echo "OWNER_LC=${GITHUB_REPOSITORY_OWNER,,}" >> $GITHUB_ENV
      - name: Detect Dockerfile & context
        run: |
          set -euo pipefail
          FOUND=$(git ls-files | grep -E '(^|/)(Dockerfile)$' | head -n1 || true)
          [ -z "$FOUND" ] && { echo "No Dockerfile"; exit 1; }
          DIR=$(dirname "$FOUND")
          [ "$DIR" = "." ] && echo "BUILD_CONTEXT=." >> $GITHUB_ENV || echo "BUILD_CONTEXT=$DIR" >> $GITHUB_ENV
          echo "DOCKERFILE_PATH=$FOUND" >> $GITHUB_ENV
      - uses: docker/setup-buildx-action@v3
      - name: Docker build (no push) - DEV conf by default
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.BUILD_CONTEXT }}
          file: ${{ env.DOCKERFILE_PATH }}
          push: false
          build-args: |
            NGINX_CONF=nginx.dev.conf
            VITE_API_BASE_URL=/api
          tags: ${{ env.REGISTRY }}/${{ env.OWNER_LC }}/${{ env.IMAGE_NAME }}:dryrun-${{ github.sha }}

  push-deploy:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4

      - name: Compute lowercase owner
        run: echo "OWNER_LC=${GITHUB_REPOSITORY_OWNER,,}" >> $GITHUB_ENV

      - name: Detect Dockerfile & context
        run: |
          set -euo pipefail
          FOUND=$(git ls-files | grep -E '(^|/)(Dockerfile)$' | head -n1 || true)
          [ -z "$FOUND" ] && { echo "No Dockerfile"; exit 1; }
          DIR=$(dirname "$FOUND")
          [ "$DIR" = "." ] && echo "BUILD_CONTEXT=." >> $GITHUB_ENV || echo "BUILD_CONTEXT=$DIR" >> $GITHUB_ENV
          echo "DOCKERFILE_PATH=$FOUND" >> $GITHUB_ENV

      - name: Figure env & tags
        id: vars
        run: |
          BR="${GITHUB_REF##*/}"
          if [ "$BR" = "main" ]; then
            echo "env=prod" >> $GITHUB_OUTPUT
            echo "latest=prod-latest" >> $GITHUB_OUTPUT
            echo "nginx_conf=nginx.prod.conf" >> $GITHUB_OUTPUT
          else
            echo "env=dev" >> $GITHUB_OUTPUT
            echo "latest=dev-latest" >> $GITHUB_OUTPUT
            echo "nginx_conf=nginx.dev.conf" >> $GITHUB_OUTPUT
          fi

      - name: Login to GHCR (push)
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - uses: docker/setup-buildx-action@v3

      - name: Build & push FE image
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.BUILD_CONTEXT }}
          file: ${{ env.DOCKERFILE_PATH }}
          push: true
          build-args: |
            NGINX_CONF=${{ steps.vars.outputs.nginx_conf }}
            VITE_API_BASE_URL=/api
          tags: |
            ${{ env.REGISTRY }}/${{ env.OWNER_LC }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.latest }}
            ${{ env.REGISTRY }}/${{ env.OWNER_LC }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

      # ---- DEV = SSH
      - name: Deploy FE to DEV via SSH
        if: steps.vars.outputs.env == 'dev'
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.DEV_HOST }}
          username: ${{ secrets.DEV_USER }}
          key: ${{ secrets.DEV_SSH_KEY }}
          script_stop: true
          script: |
            set -euo pipefail
            REGISTRY="${{ env.REGISTRY }}"
            IMAGE="${{ env.OWNER_LC }}/${{ env.IMAGE_NAME }}"
            TAG="${{ github.sha }}"
            LATEST="${{ steps.vars.outputs.latest }}"
            NET="duckon-dev-net"

            docker network create "$NET" || true
            # FE는 BE와 같은 네트워크면 OK
            docker pull "$REGISTRY/$IMAGE:$TAG" || docker pull "$REGISTRY/$IMAGE:$LATEST"

            docker rm -f duckon-front-dev 2>/dev/null || true
            docker run -d --name duckon-front-dev \
              --network "$NET" \
              -p 80:80 \
              --restart unless-stopped \
              "$REGISTRY/$IMAGE:$TAG"

            sleep 2
            curl -sI http://127.0.0.1/ | head -n1 || true

      # ---- PROD = SSM
      - name: Install jq (for SSM params)
        if: steps.vars.outputs.env == 'prod'
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Configure AWS (PROD)
        if: steps.vars.outputs.env == 'prod'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          aws-region: ${{ vars.AWS_REGION_PROD }}

      - name: Deploy FE to PROD via SSM
        if: steps.vars.outputs.env == 'prod'
        run: |
          set -euo pipefail
          REGION="${{ vars.AWS_REGION_PROD }}"
          INSTANCE="${{ vars.PROD_INSTANCE_ID }}"
          REPO="${{ env.REGISTRY }}/${{ env.OWNER_LC }}/${{ env.IMAGE_NAME }}"
          TAG="${{ github.sha }}"
          LATEST="${{ steps.vars.outputs.latest }}"

          SCRIPT=$(cat <<'EOS'
          set -eu
          REPO="__REPO__"
          TAG="__TAG__"
          LATEST="__LATEST__"

          APP="duckon-front-prod"

          # duckon-proxy와 같은 네트워크로 자동 연결
          NET=$(docker inspect -f '{{range $k,$v := .NetworkSettings.Networks}}{{printf "%s " $k}}{{end}}' duckon-proxy 2>/dev/null | awk '{print $1}')
          [ -z "$NET" ] && NET="bridge"
          echo "Using network: $NET"

          echo "Pulling image $REPO:$TAG (fallback: $LATEST)"
          docker pull "$REPO:$TAG" || docker pull "$REPO:$LATEST"

          echo "Restart container"
          docker rm -f "$APP" 2>/dev/null || true
          docker run -d --name "$APP" \
            --network "$NET" \
            --restart unless-stopped \
            "$REPO:$TAG"

          echo "Containers:"
          docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}'
          EOS
          )
          SCRIPT="${SCRIPT//__REPO__/$REPO}"
          SCRIPT="${SCRIPT//__TAG__/$TAG}"
          SCRIPT="${SCRIPT//__LATEST__/$LATEST}"

          jq -n --arg script "$SCRIPT" '{commands: [$script]}' > ssm-params.json
          CMD_ID=$(aws ssm send-command \
            --instance-ids "${{ vars.PROD_INSTANCE_ID }}" \
            --document-name "AWS-RunShellScript" \
            --parameters file://ssm-params.json \
            --comment "DuckOn FE prod deploy $TAG" \
            --region "$REGION" \
            --query "Command.CommandId" --output text)
          echo "CommandId: $CMD_ID"

          aws ssm wait command-executed --command-id "$CMD_ID" --instance-id "${{ vars.PROD_INSTANCE_ID }}" --region "$REGION"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "${{ vars.PROD_INSTANCE_ID }}" --region "$REGION" --output table
